import { WeverseAuthorization, WeverseOauthCredentials, WeversePasswordAuthorization, WeverseTokenAuthorization, WeverseLoginPayloadInterface, WeverseInitOptions, GetOptions, WvHeaders, ListenOptions, NewNotifications } from "../types";
import { AxiosResponse } from 'axios';
import { WeverseArtist, WeverseCommunity, WeverseNotification, ClientNotifications, WeversePost, WeverseComment, WeverseMedia, WeverseEvents } from "../models";
import TypedEmitter from 'typed-emitter';
declare const WeverseEmitter_base: new () => TypedEmitter<WeverseEvents>;
/**
 * WeverseEmitter allows the WeverseClient to emit events and provides methods for doing so
 * @class
 */
declare class WeverseEmitter extends WeverseEmitter_base {
    constructor();
    /**
     * @param  {Error} err - The error to be emitted
     */
    newError: (err: Error) => boolean;
    /**
     * @param  {boolean} initialized - whether initialization succeeded
     */
    ready: (initialized: boolean) => boolean;
    /**
     * @param  {WeverseNotification} notification - new Notification to be emitted
     */
    newNotif: (notification: WeverseNotification) => boolean;
    /**
     * @param  {WeversePost} post - new Post to be emitted
     */
    newPost: (post: WeversePost) => boolean;
    /**
     * @param  {WeverseMedia} media - new Media to be emitted
     */
    newMedia: (media: WeverseMedia) => boolean;
    /**
     * @param  {WeverseComment} comment - the Comment that was retrieved
     * @param  {WeversePost} post - the Post associated with the Comment
     */
    newComment: (comment: WeverseComment, post: WeversePost) => boolean;
    /**
     * @param  {boolean} result - boolean result of the login attempt
     */
    loginResult: (result: boolean) => boolean;
    /**
     * @param  {boolean} status - result of the poll attempt. If true, Weverse was successfully polled
     */
    polled: (status: boolean) => boolean;
}
/**
 * Client for the private Weverse api
 * @prop {WeverseCommunity[]} communities - The communities associated with the Weverse account
 * @prop {WeverseArtist[]} artists - All artists in all communities associated with the account
 * @prop {ClientNotifications} notifications - Subclass handling all notifications for the account
 * @prop {WeversePost[]} posts - All posts that have been retrieved by this client
 * @fires WeverseClient#error
 * @fires WeverseClient#init
 * @fires WeverseClient#notification
 * @fires WeverseClient#post
 * @fires WeverseClient#media
 * @fires WeverseClient#comment
 * @fires WeverseClient#login
 * @fires WeverseClient#poll
 * @class
 */
export declare class WeverseClient extends WeverseEmitter {
    protected _verbose: boolean;
    protected _authorization: WeversePasswordAuthorization | WeverseTokenAuthorization;
    protected _authType: 'token' | 'password';
    protected _loginPayload: WeverseLoginPayloadInterface | null;
    protected _authorized: boolean;
    protected _credentials: WeverseOauthCredentials | null;
    protected _refreshToken?: string;
    protected _weverseId?: number;
    protected _headers: WvHeaders;
    communities: WeverseCommunity[];
    protected _communityMap: Map<number, WeverseCommunity>;
    artists: WeverseArtist[];
    protected _artistMap: Map<number, WeverseArtist>;
    notifications: ClientNotifications;
    posts: WeversePost[];
    protected _postsMap: Map<number, WeversePost>;
    protected _commentsMap: Map<number, WeverseComment>;
    protected listener: ReturnType<typeof setInterval> | undefined;
    /**
     * @param  {WeverseAuthorization} authorization - either {token: string} or {username: string, password: string}
     * @param  {boolean} verbose - optional; defaults to false
     */
    constructor(authorization: WeverseAuthorization, verbose?: boolean);
    /**
     * init options:
     *   allPosts: boolean - Whether to load all posts from each community into memory. This will be slow
     *   allNotifications: boolean - Whether to load all notifications for the Weverse account. Will be slow.
     *   allMedia: boolean - not currently implemented
     * @param  {WeverseInitOptions} options - optional
     * @returns {Promise<void>}
     * @public
     */
    init(options?: WeverseInitOptions): Promise<void>;
    /**
     * Tells the client to start or stop listening for new notifications.
     * Options:
     *   listen: boolean - Whether the client should be listening
     *   interval: boolean - Interval in MS to listen on
     *   process: boolean (optional) - Whether new notifications should be processed into Posts/Comments/Media
     * @param  {ListenOptions} opts
     * @public
     */
    listen(opts: ListenOptions): void;
    /**
     * Method passed to setInterval if client is listening for new notifications
     * @param  {boolean} process - Whether to process new notifications into Posts/Comments/Media
     * @returns {Promise<void>}
     * @protected
     */
    protected checker(process: boolean): Promise<void>;
    /**
     * Attempts to use a refresh token to get a new Weverse access token
     * @returns {Promise<boolean>} Whether a new access token was granted
     * @public
     */
    tryRefreshToken(): Promise<boolean>;
    /**
     * Only used for password authentication. Attempts to login either with login given when
     * the client was created, or with optional credentials parameter
     * @param  {WeversePasswordAuthorization} credentials - optional, will override initial credentials
     * @returns {Promise<void>}
     * @public
     */
    login(credentials?: WeversePasswordAuthorization): Promise<void>;
    /**
     * Force a credentials check. If login has already been converted to a token, token will be checked.
     * @returns {Promise<boolean>} - whether the check was successful
     * @public
     */
    checkLogin(): Promise<boolean>;
    /**
     * Load all communities associated with this Weverse account. Returns the communities
     * but also adds them to the cache.
     * Options:
     *   init: boolean - Whether this method was called by the init method and should skip the login check
     * @param  {GetOptions} opts - optional
     * @returns {Promise<WeverseCommunity[]>}
     * @public
     */
    getCommunities(opts?: GetOptions): Promise<WeverseCommunity[] | null>;
    /**
     * Get the artists in a community. Adds them to the cache and returns.
     * Options:
     *   init - whether this method was called by init method and the login check should be skipped
     * @param  {WeverseCommunity} c
     * @param  {GetOptions} opts - optional
     * @returns {Promise<WeverseArtist[] | null>} returns null if failed to fetch artists
     */
    getCommunityArtists(c: WeverseCommunity, opts?: GetOptions): Promise<WeverseArtist[] | null>;
    /**
     * @template getCommunityPosts
     * @param  {WeverseCommunity|number} c - The community for which posts should be retrieved (object or number)
     * @param  {number} pages - The number of pages of results to be retrieved
     * @returns {Promise<WeversePost[] | null>} - Returns null if failed to get posts; returns only new posts not in cache
     * @emits WeverseClient#post
     */
    getCommunityPosts(c: WeverseCommunity, pages: number): Promise<WeversePost[] | null>;
    getCommunityPosts(c: number, pages: number): Promise<WeversePost[] | null>;
    /**
     * Note: If process = true, events will be emitted for new notifications AND new Posts/Comments/Media
     * @param  {number} pages - Optional number of pages to get; defaults to 1
     * @param  {boolean} process - Whether notifications should be processed into Posts/Comments/Media
     * @returns {Promise<WeverseNotification[] | null>} - Returns only new notifications not already in cache, or null on failure
     */
    getNotifications(pages?: number, process?: boolean): Promise<WeverseNotification[] | null>;
    /**
     * Get one page of the most recent notifications
     * @param  {NewNotifications} opts - {process: boolean} - whether to process notifications into content
     * @returns {Promise<WeverseNotification[] | null>}
     */
    getNewNotifications(opts?: NewNotifications): Promise<WeverseNotification[] | null>;
    /**
     * Get a specific media object by id
     * Will first check local cache, then request from Weverse
     * @param  {number} id
     * @param  {WeverseCommunity} community
     * @returns {Promise<WeverseMedia | null>} - Returns only if media did not exist in cache
     */
    getMedia(id: number, community: WeverseCommunity): Promise<WeverseMedia | null>;
    /**
     * Gets all artist comments on a given post. Returns only new comments.
     * @param  {WeversePost} p
     * @param  {WeverseCommunity} c
     * @param  {number} cId?
     * @returns {Promise<WeverseComment[] | null>}
     */
    getComments(p: WeversePost, c: WeverseCommunity, cId?: number): Promise<WeverseComment[] | null>;
    /**
     * Get one post by id. First checks the cache, then requests from Weverse.
     * @param  {number} id
     * @param  {number} communityId
     * @returns {Promise<WeversePost | null>}
     * @public
     */
    getPost(id: number, communityId: number): Promise<WeversePost | null>;
    /**
     * Process one notification. If it refers to a post, comment, or media, attempt to add to cache
     * @param  {WeverseNotification} n
     * @returns {Promise<void>}
     */
    protected processNotification(n: WeverseNotification): Promise<void>;
    /**
     * Encrypt provided password with Weverse public RSA key and create payload to send to login endpoint
     * Adds the payload as a property of the client, returns void
     * @returns {void}
     */
    protected createLoginPayload(): void;
    /**
     * Check if the current token (provided or recieved from Weverse) is valid
     * @returns {Promise<boolean>}
     */
    checkToken(): Promise<boolean>;
    /**
     * If the client receives a 401 unauthorized from Weverse, will attempt to refresh credentials
     * @param  {AxiosResponse} response
     * @param  {string} url
     * @returns {Promise<boolean>}
     */
    protected handleResponse(response: AxiosResponse, url: string): Promise<boolean>;
    /**
     * Log something if verbose = true
     * @param  {any} ...vals
     */
    protected log(...vals: any): void;
    /**
     * Check the community hashmap for a given id
     * @param  {number} id
     * @returns {WeverseCommunity | null}
     */
    communityById(id: number): WeverseCommunity | null;
    /**
     * Check the artist hashmap for a given id
     * @param  {number} id
     * @returns {WeverseArtist | null}
     */
    artistById(id: number): WeverseArtist | null;
    /**
     * Check the post hashmap for a given id
     * @param  {number} id
     */
    post(id: number): WeversePost | null;
    get authorized(): boolean;
    get credentials(): WeverseOauthCredentials | null;
    get verbose(): boolean;
    get authorization(): WeversePasswordAuthorization | WeverseTokenAuthorization;
    get authType(): "password" | "token";
    get loginPayload(): WeverseLoginPayloadInterface | null;
    get refreshToken(): string | undefined;
    get weverseId(): number | undefined;
    get requestHeaders(): WvHeaders;
}
export {};
/**
 * Error event
 *
 * @event WeverseClient#error
 * @type {Error}
 */
/**
 * Init event
 * Whether initialization was successful
 * @event WeverseClient#init
 * @type {boolean}
 */
/**
 * Notification event
 * New notification
 * @event WeverseClient#notification
 * @type {WeverseNotification}
 */
/**
 * Post event
 * New post
 * @event WeverseClient#post
 * @type {WeversePost}
 */
/**
 * Media event
 * New media
 * @event WeverseClient#media
 * @type {WeverseMedia}
 */
/**
 * Comment event
 * New comment. Provides comment and post.
 * @event WeverseClient#comment
 * @type {WeverseComment}
 * @type {WeversePost}
 */
/**
 * Login event
 * Result of login attempt.
 * @event WeverseClient#login
 * @type {boolean}
 */
/**
 * Poll event
 * Result of poll attempt.
 * @event WeverseClient#poll
 * @type {boolean}
 */ 
